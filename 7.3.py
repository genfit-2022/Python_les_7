#   3. Реализовать программу работы с органическими клетками, состоящими из ячеек. Необходимо создать класс
#   Клетка. В его конструкторе инициализировать параметр, соответствующий количеству ячеек клетки (целое число).
#   В классе должны быть реализованы методы перегрузки арифметических операторов: сложение (__add__()), вычитание
#   (__sub__()), умножение (__mul__()), деление (__truediv__()). Данные методы должны применяться только к клеткам
#   и выполнять увеличение, уменьшение, умножение и целочисленное (с округлением до целого) деление клеток, соответственно.
#
#   Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно равняться сумме ячеек исходных двух клеток.
#   Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если разность количества ячеек двух клеток больше
#   нуля, иначе выводить соответствующее сообщение.
#   Умножение. Создаётся общая клетка из двух. Число ячеек общей клетки определяется как произведение количества ячеек этих
#   двух клеток.
#   Деление. Создаётся общая клетка из двух. Число ячеек общей клетки определяется как целочисленное деление количества ячеек
#   этих двух клеток.
#   В классе необходимо реализовать метод make_order(), принимающий экземпляр класса и количество ячеек в ряду. Данный метод
#   позволяет организовать ячейки по рядам.
#
#   Метод должен возвращать строку вида *****\n*****\n*****..., где количество ячеек между \n равно переданному аргументу.
#   Если ячеек на формирование ряда не хватает, то в последний ряд записываются все оставшиеся.
#
#   Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5. Тогда метод make_order() вернёт
#   строку: *****\n*****\n**.
#   Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5. Тогда метод make_order() вернёт
#   строку: *****\n*****\n*****.
#
#       Подсказка:      подробный список операторов для перегрузки доступен по ссылке.

class Clet:
    def __init__(self, zv):
        self.zv = int(zv)

    def __str__(self):
        return f'Результат операции: {self.zv * "*"}'

    def __add__(self,dr):
        return Clet(self.zv + dr.zv)

    def __sub__(self, dr):
        return self.zv - dr.zv if (self.zv - dr.zv) > 0 else print('Отрицательное значение!')

    def __mul__(self, dr):
        return Clet(int(self.zv * dr.zv))

    def __truediv__(self, dr):
        return Clet(round(self.zv // dr.zv))

    def make_order(self, cl_rw):
        rw = ''
        for i in range(int(self.zv / cl_rw)):
            rw += f'{"*" * cl_rw} \\n'
        rw += f'{"*" * (self.zv % cl_rw)}'
        return rw

clet_1 = Clet(3)
clet_2 = Clet(3)
print(clet_1)
print(clet_2)
print(clet_1 + clet_2)
print(clet_2 - clet_1)
print(clet_2.make_order(5))
print(clet_1.make_order(10))
print(clet_1 / clet_2)